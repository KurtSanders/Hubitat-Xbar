#!/usr/bin/env PYTHONIOENCODING=UTF-8 /usr/bin/python3
# -*- coding: UTF-8 -*-
#############################################################################################################################
# Author: SandersSoft (c) 2020,2021,2022,2023
# Hubitat_XBar.5m.py
# https://raw.githubusercontent.com/KurtSanders/Hubitat-Xbar/main/Hubitat_XBar.5m.py
# This executable Python3 file must be installed in the XBar Plugins system directory
#
# <xbar.title>Hubitat → XBar for MacOS</xbar.title>
# <xbar.version>v1.0</xbar.version>
# <xbar.author>Kurt Sanders</xbar.author>
# <xbar.author.github>KurtSanders</xbar.author.github>
# <xbar.desc>Provides a view and control of Hubitat sensors from the macOS menubar</xbar.desc>
# <xbar.image>https://raw.githubusercontent.com/KurtSanders/Hubitat-Xbar/main/Images/Hubitat-Xbar-Menu.png</xbar.image>
# <xbar.dependencies>Hubitat Hub, MacOS, Python3</xbar.dependencies>
# <xbar.abouturl>http://kurtsanders.com/</xbar.abouturl>
# <xbar.var>string(VAR_Hubitat_Oauth_String=""): Required: the Hubitat Oauth string generated from the Hubitat XBar App.</xbar.var>
# <xbar.var>boolean(VAR_verbose_schedule_notify=true): Whether to be verbose or not.</xbar.var>#
# <xbar.var>boolean(VAR_verbose_request_notify=true): Whether to be verbose or not.</xbar.var>
#
# Copyright 2018,2019,2020,2021,2022,2023 Kurt Sanders
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
# for the specific language governing permissions and limitations under the License.
#############################################################################################################################
import base64
import decimal
import io
import json
import os
import re
import subprocess
import sys
import tempfile
import time
import timeit
import urllib.error
import urllib.parse
import urllib.request
from sys import exit

start = timeit.default_timer()
DEBUG = False
scriptFile=__file__

# Provide text notifications to macOS via oascript
def notify(title, text):
# args = ["-e", "display notification \"{}\" with title \"{}\"".format(text, title)]
    subprocess.call(["osascript", "-e", "display notification \"{}\" with title \"{}\"".format(text, title)])

# Define the env variables set by the xbar application
xbarVARname = "VAR_Hubitat_Oauth_String"
xbarOauthString = os.environ.get(xbarVARname)
XBARDarkMode = True if os.environ.get("XBARDarkMode") == "true" else False

if xbarOauthString is None:
    try:
        with open("{}{}".format(scriptFile,".vars.json")) as xbar_json_file:
            jsonvars  = json.load(xbar_json_file)
            xbarOauthString = jsonvars[xbarVARname]
    except (FileNotFoundError, KeyError):
        notify ("Severre Error",
                "Please set the required Xbar environment variable {} in the Xbar Pluggin {}".format(xbarVARname,os.path.basename(scriptFile)))
        exit(1)

smartAppSecret = xbarOauthString.split("~")[0]
smartAppURL = xbarOauthString.split("~")[1]
verbose_schedule_notify = os.environ.get("VAR_verbose_schedule_notify",False)
verbose_request_notify = os.environ.get("VAR_verbose_request_notify",False)

#Check to insure required variables are defined
if ((smartAppSecret is None) or (smartAppURL is None)):
        notify ("Severre Error",
                "Please set the required Xbar environment variable {} in the Xbar Pluggin {}".format(xbarVARname,os.path.basename(scriptFile)))
        exit(1)


def hubitatAPIRequest(url):
    header = {"Authorization": "Bearer " + smartAppSecret}
    request = urllib.request.Request(url, None, header)
    # Getting the response
    try:
        urllib.request.urlopen(request)
    except (urllib.error.HTTPError, urllib.error.URLError) as err:
        notify("Xbar Error","HTTPS Error Encountered: Communicating to Hub API caused the following error: {}".format(str(err)))
        exit(1)

# Check for a passed argument of 'request' from Xbar application
if ((len(sys.argv)>1) and (sys.argv[1] == "request")):
    hubitatAPIRequest(sys.argv[2])
    if sys.argv[3].isdigit():
        waittime = int(sys.argv[3])
    else:
        waittime = 3
    notify("Xbar → Hubitat: {}".format(sys.argv[1].title()),"{}\nWaiting {} secs for XBar auto refresh status".format(sys.argv[4],waittime))
    time.sleep(waittime)
    notify("Xbar → Hubitat","XBar auto refresh started")
    request = "xbar://app.xbarapp.com/refreshPlugin?path={}".format(os.path.basename(__file__))
    subprocess.call(['open', request])
        
# Define class for useful functions
class myUtilities:
#    def __init__(self):
    def getImageString(self,imageName):
        self.image_icons_dict = {
            'up': 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAyQACAALwzIS'
            'XAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AQHACkSBTjB+AAAALNJREFUOM'
            'vVk70NAjEMhb87WYiGBZAQU7ABNSVSWpZgEEagsJDoKBELUCEKFuBuCKTw0xyQC0lIC'
            'e5i+/k9/wT+3opUUJQhcAUqa8I5ZQT4tANwioGTCkQZA9vmOQE2oUJFhL0DXBz33RpK'
            'UfCLfLTQJMx9IlEWuQr6QB3prGtNS1lwiMvEYo7ekNsKRBkB+y+rH1hDFVOwy7ids+g'
            'bVzrsM6CXeYDTF85xroB1ZoHb73ymB5RhJkpZTihGAAAAAElFTkSuQmCC',
            'down': 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QABACnAADQ9'
            'FZaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AQHACQ1FZwK3gAAAMRJRE'
            'FUOMvNkjEKAjEQRZ+jKNjYKh5AbzCdjVcQj+BFPIKlp7EMeAJrUbASQVCEr80uG9c'
            'Nbqe/Cgn/5WUI/DqNfBHM+kCzbs+lPUAr2pwBq5qABbB+M8gszkDvS/kOdAG5VBgE'
            'M4ApsP0CGLukjxlEoA0wSZR3Lo0qhxhZDIBDAmDA0wsBLD51CZeOwLKivHbprZx6A'
            'kAHuEXbD5fawYwywMqAzOKeDTTPvKqcTGZBMLsGs0utn5gADYEHcKp9e9ni//MCDt'
            'NCE3qjsIwAAAAASUVORK5CYII=',
            "closed": "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", 
            "greenImage": "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", 
            "armedNight": "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", 
            "armedAway": "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", 
            "disarmed": "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", 
            "locked": "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", 
            "new-logo": "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", 
            "number": "iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGaADAAQAAAABAAAAGQAAAACryfpdAAAACXBIWXMAAAsTAAALEwEAmpwYAAACZmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI1PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI1PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+ClDRJRoAAAIESURBVEgNvZXJLkRBFIZNCSGGWBC2BC/ASqwkFsIbWFh5D+8g8QYiEjsJO/aWbAwtwZaFEPPwf/fWn65ut2+6b4uT/DWcOvX/dU7doaWltrVqqaP2crLSrhbkGkRZ1ibnV1joVj8jjAgDwotwJ5wKlwJG/HcA81xD1MKDGq8Lx8KDYBL6T+FC2BXmBRtiuQa5U1/WuCRUE7/J9y6Qpdc+NN4QOgXMHOmsqnUGa/JzUp8YEkhjYsbEIGixA40pJ5Yp5DTJIBYwQV6PoMW2NTaXDy1X5R2UNHcGecTVa7HQasJaFkumfky55CICFnQFzsTjslVk06MFniI2cAfe2GhvoSVxYImI6zctx0TiLpcvTBvqfHKLJJstMqpZr8BJHJgEFGymwr6KTPqCkwv8C5Gh+HDO5DVWjgMKjh/jfRa5l5NL5iWib9ZuAkHCZZETOa8ESkXJmrXDagK/JztaQNlvL+MiYP+vJ9XfmVktcjcQk02jAnw82bMpZJrLxteUQH8U6xWywK32jgcFc4Zp+bHtkmdfgJy0/QbniVngWfGLAuYrSGdRa+V++bYEEyNE+bLgGJ6mBQFz+dNZRusA+hWBX6yJsnrKyh2MCZj3p7PQZr3dBHJ6jC/BnMB/ZlIYFp6Ea+FI2BPOBYwSIVq3Ie7y1bMpNzYrk5g0Xo/HlM4Wj+37//4HDpvgjQ/VGxIAAAAASUVORK5CYII=", 
            "off": "iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAB6gAwAEAAAAAQAAAB4AAAAA6YkVPwAABIJJREFUSA3tVlloXFUY/s65yyxJZtJs02QaQ200LbV1YpRqgqIPBRN9MCj0SbBaEBH1UUGUoAiKD2KFilRRBFFB2weljRbbZoWKacaaQmNmzJ5oJU4yZpmZe889/ufOQqITBRFEyQmZs/378p0LbI2tCPzfIsA2cygajYbTzLg2ZVvVjMZmdMXOJQ2vbvwspPVDayQyW4xmg8DB6ekKZz7RLg2+nzNeJzS9RkIGDMdhkA4cKYrJ+MOZlIz+kATHVU2yWWE73/Habadb6+t/yRMXFJ8butyoa/J+Ynk0WB7cqVtpOMlf4TgCjumB8PkArrl8TMo8/6Yz4xymYUIQ/1IiMS65fMsW2qd3teyNKSZXcTQ6Gl6WVpff7ztir65BLibgGY/BMzUOlskgE65HalcTRPk2CNMkroK9mypef2EYBgwyYnV15e1SZnRFIk2zuiJYc6wnHE3rtJNJmNFvUNPdDXN+Dsyy6JaCrSz3erHQ3oFkywFYNaHcHaCRZ5RSSkM2CmrPOGVGOMSpbKQ1pcm2XVmdpGuBjp/R+oYu3w2NHfZouM575QpqPvoAntgYtKUkkM6Qx2nw5RXwRALe2Sk41dVYC22H1HQ3DeOTU0ilUygtKXX3E5MzGI3FiTVDCoGJ6RnE4uNkv0QgEPBTjM2HHn58RmfM6RC6WR+cm0HJwHn4Bgfg1IUhycP8kG5cAHNgGIFrGpCuqsLinv0Yjl7Cle/j8HhN3LRvL3Y2NGDwwtdIkdJbmiMQQuB8bz8pDCJYVoba2u3gjO1guuhg/RdH+oXfe0NNf2+w8tUu6NxPRcTzOjfMzBYQMo3koQcRv+8BHGy5ccN979C3uGPd2bsfn8ThQ50Fmr7hEQouW3IcOcI5Z7voxqeKSJ//8U8LR2ocfGkRWirt5k9J/OyrXrx2/D21LIwnn3sJn/cMkKdl7tkLr7+JL/ovUJUbqhZ8Smdx1woi/t7i6IvPwlHFla03PP/UY9RWuU1OpE5ux2ntk6Zp2pQDXVFv0i6MhIlgOVW4J9uHxHj6zFlcXcjigswJP/b+hwiFQoiNjblqTnx5FmWlJbkosTWlkzyWF7ntrAgqmpWD94LPz4DMzdm1cWKjE0hTOyV374HBsmBy7OUufHL8qEuo2kiNHeEwTF2Dz0+gQ6OqshK6prn/pG9F6SQH+SluWwdWa2vrnLY74Y3HYU5OgqdSkAqpyDQmqJfJmExbM5K3tmG5sYmKBOihYpqidvH5vAhRb6vYnjjTg5LSUqSoDoIUHbVnLN/rqrflDGx+yjWxbzj6iuSeR7yZVOVGAMm4FmcBxEMAcs9fAgi1SwFMFHN+r1Nh2VZmQUK8c3tz5Gm3Q400e8P2iAo9EDiSufk2TDfuLgKZ1xNkVriQmUU01yYqGie7yP3mESx/qPZ5yLQt66TSpe4KoPuvPBJ56wYHpyssPdFumvo+qWl1NpyQBA8wRzCDkgMUL7o8v5qFehNzzyLX+E/URnOE15f4WqC7tbXIs7ieWa3/iQ8BD30IRDb5EPi9vq39VgT++xH4DWckMv5bNriNAAAAAElFTkSuQmCC", 
            "on": "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", 
            "open": "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", 
            "redImage": "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", 
            "thermoImage": "iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAYAAACN1PRVAAAAAXNSR0IArs4c6QAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAIUAAAABAAAAhQAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAG6ADAAQAAAABAAAAGwAAAAA1W3haAAAACXBIWXMAABR0AAAUdAG5O1bwAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMwidZAAAC6UlEQVRIDbWWPWgUQRTHZ97sR3LJETkwKqJR7sgFohAwTcQiiilMITZaKtgJFoKl2NlpZyXY2YpooVgIplFIYSUpEoSIIF5IwuWSyCXZmfd8s+HWzXqXnRMdbvdm5+P95v/mzYcUXaTxsbHpen3trgI5AEq9IKUez8/Pb7iaANeGp0dGzjQaG/dBwlMZBDeNMecF4i3ur1xtODWcFMJb6e2/JiRtfvm6+Gh1dXVp8GDpJ6G4dKBU+lCv19ddgE7KlkdH2WvCVwBrLaOEsg4AOwGikw3bz7khSsk/mXiCiACJZAvu8u8Ms8YQBaWNyj1f6Zr2+a5gAGKPki5Z7m5sN9Y95HYNMmVe5nvfT54iXa1Wixz2A+wSgyRx3w6ZSmc3soomKNlPWj/h5yNH4lmQcpMfZ2+6wwi0ISrx2jopSB5lVRWQgrb+B0wwQSIHOyEriTMmE5wZp/356ayMCZl46Gq6YrJzgDApnhtpkWTH6DzORKJzj5YydiRT8S9QXQzvt7K0N2OxycjzMs7KOCh2LcdvYG1x4qj5x6G/vb0twfdDYQ3LXQ5DjCHhh2HoPGCnhkEA5xBxWpKcY9QAR4gnyPwgo0NAfb1SqYR5LrT1yZHRqfEJTqjxIRDNCAVTDJ2wqwANDgeB/yoyeKG/UNiqLS3NdbLRKs+FHR4cvKMjE0ngXcPgFXYfe5O1ERX5XQ18/+VOFF08NjT0uVarLbcMt/vPdSNpPOX56hsrumwNMCR+LBQNHTdkejRvzJuNxlQ7QLosd1FrRBmEvuZgVBaUTnbFsWo7AhFwpKTr2uVzlSkPFhlyiC8Ab1hdYsPmlVLLfDlZMRqbDJxJKjtkcmHCmGcmisa5/3ulvHdWhVUInvoe9IQP2JuTfcW+13MLC586MJLi9HaQFGYyMFwuX+W5u81n2AxvOutSkccHaMQ6Jwu9vYuFYvHe7Oxs7nXOBWbZcqRcnjCIN/ikOWL3fyRs8jS95Rl77nor/gWDODR3hnrwgQAAAABJRU5ErkJggg==", 
            "unknown": "iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAYAAADgKtSgAAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABegAwAEAAAAAQAAABcAAAAAVd28qgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAAzFJREFUSA111FmIT1EcwHGDYexjCGNpGEbMYjfKLiEaEg9EWbJkKx4kMp4kokhZaxJZHoQsqbEkxoO1bJElYx5kGabGkJ3x/d7/nPHH+NXnnnPu/Z/fPdv9J9SqORK4rZ81P47uZnOdgSwkIRFPsB+XUGmCv6M2N+KTNqPdAHb+ineYgGnYiLoYgjLcxzw8wvr45NZlYhPlIB0ZSEFjfEIlOmIycrEYuzACDmINduCSyQxLOxndMBHdUYJzVWU5ZRrysRsX0Rb2e4kp6IKdqMAJRIktjVE4gEU2/hN7uN8EdeKez6Z+HO5DiMJQsXRax9DDBuEU6yM+SVfaBegEw/U2RqJDVIv1s1oYOrquqzEfz2Bi1/cHnHYvLEcmesMBOG33px0G4i1e4zvmoNzkjm4VjsJEa2HnSXiOUqTiA07iGtzs/rgI92sM7uIN3OBBWOexcwNb4TRa4j1S4HH6BuMWXLLRcITL4LFcCAfRBgtQBHOtwFuTu4luhuEoXIpiOIvH8DfGXjSEy+dS+Ny6iT0EnqAXuI5XSLDjUJyC4ci/wPVsDzu6robtQ3AWw2CCJdgAR+wHtAvd4GmqdLfdvM8wniIPW3AWnl/3xdncwSa0wCxUILzYQVovwTg4Q5e31hkvRJi+o82ES2SE0rqnxr+DvyP8pikPtsFZRuc0JLVtOF2FcG0dvXE7VvxzNbm/S8ZHRAfBZXGNfYEPjdQqnnOVwg5GGEhYjtjd39eOVMtgv2jkNymH4wIMpz4eHjk/iHcoxwPcgBFG6susW/pCj6qzcz+i6fqWuTgOZ/IMRTBRMfzIeiIbfjh+hY7OpTKhM06Emz4ThfAg+MJoZwsoB9ggfEFN0Zqbq7Ay7mEOdWdpLIUfT9gf70XRl+theISMegjTdQTxHTyKRnPkIxdpOIgMGNGoY9XYdQbFfsS/wCeN4PFMRmf4uTvTeTDScQQjbRDVA3F0YXN84AvysBlXYWRhOhyxJ0f+ed3DcLhfW1EEozqfFaP6BvU+8A/JpdmHK3DDkuDm+9vBmApP1Hb4ZRvxeaJG7PafD1waT8dY9EPo5JT9Li7jPB7Cf0cj/CbW4voLDfW7VhbDSSIAAAAASUVORK5CYII=", 
            "unlocked": "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"
        }
        self.image = self.image_icons_dict.get(imageName,"iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAYAAADgKtSgAAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABegAwAEAAAAAQAAABcAAAAAVd28qgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAAzFJREFUSA111FmIT1EcwHGDYexjCGNpGEbMYjfKLiEaEg9EWbJkKx4kMp4kokhZaxJZHoQsqbEkxoO1bJElYx5kGabGkJ3x/d7/nPHH+NXnnnPu/Z/fPdv9J9SqORK4rZ81P47uZnOdgSwkIRFPsB+XUGmCv6M2N+KTNqPdAHb+ineYgGnYiLoYgjLcxzw8wvr45NZlYhPlIB0ZSEFjfEIlOmIycrEYuzACDmINduCSyQxLOxndMBHdUYJzVWU5ZRrysRsX0Rb2e4kp6IKdqMAJRIktjVE4gEU2/hN7uN8EdeKez6Z+HO5DiMJQsXRax9DDBuEU6yM+SVfaBegEw/U2RqJDVIv1s1oYOrquqzEfz2Bi1/cHnHYvLEcmesMBOG33px0G4i1e4zvmoNzkjm4VjsJEa2HnSXiOUqTiA07iGtzs/rgI92sM7uIN3OBBWOexcwNb4TRa4j1S4HH6BuMWXLLRcITL4LFcCAfRBgtQBHOtwFuTu4luhuEoXIpiOIvH8DfGXjSEy+dS+Ny6iT0EnqAXuI5XSLDjUJyC4ci/wPVsDzu6robtQ3AWw2CCJdgAR+wHtAvd4GmqdLfdvM8wniIPW3AWnl/3xdncwSa0wCxUILzYQVovwTg4Q5e31hkvRJi+o82ES2SE0rqnxr+DvyP8pikPtsFZRuc0JLVtOF2FcG0dvXE7VvxzNbm/S8ZHRAfBZXGNfYEPjdQqnnOVwg5GGEhYjtjd39eOVMtgv2jkNymH4wIMpz4eHjk/iHcoxwPcgBFG6susW/pCj6qzcz+i6fqWuTgOZ/IMRTBRMfzIeiIbfjh+hY7OpTKhM06Emz4ThfAg+MJoZwsoB9ggfEFN0Zqbq7Ay7mEOdWdpLIUfT9gf70XRl+theISMegjTdQTxHTyKRnPkIxdpOIgMGNGoY9XYdQbFfsS/wCeN4PFMRmf4uTvTeTDScQQjbRDVA3F0YXN84AvysBlXYWRhOhyxJ0f+ed3DcLhfW1EEozqfFaP6BvU+8A/JpdmHK3DDkuDm+9vBmApP1Hb4ZRvxeaJG7PafD1waT8dY9EPo5JT9Li7jPB7Cf0cj/CbW4voLDfW7VhbDSSIAAAAASUVORK5CYII=")
        return self.image
    def devWaitSecs(self,deviceType):
        self.devices_dict = {
            "hsmState":5,
            "locks":10,
            "modes":5,
            "musicplayers":5,
            "switches":2,
            "thermostats":10,
            "valves":10,
            "waters":10
            }
        self.waitSecs=self.devices_dict.get(deviceType,1)
        return self.waitSecs


# Define class for formatting numerical outputs
# Define NumberFormatter class
class NumberFormatter:
    def __init__(self):
        self.decimalRounding = 0
        self.staticDecimalPlaces = -1

    def setRoundingPrecision(self, precision):
        self.decimalRounding = precision

    def setStaticDecimalPlaces(self, places):
        self.staticDecimalPlaces = places

    def getNumberOfDecimals(self, number):
        try:
            r = round(float(number), self.decimalRounding)
        except (ValueError, TypeError, AttributeError):
            return 0
        if r % 1 == 0: return 0
        return abs(decimal.Decimal(str(r)).as_tuple().exponent)
    def formatNumber(self, number):
        try:
            r = round(float(number), self.decimalRounding)
        except (ValueError, TypeError, AttributeError):
            return number
        if self.staticDecimalPlaces != -1:
            formatter = "{0:." + str(self.staticDecimalPlaces) + "f}"
            return formatter.format(r)
        else:
            if r % 1 == 0:
                return str(int(r))
            else:
                return str(r)

# String Case Formatter
def TitleCase(var):
    return var if var is None else var.capitalize()

colorHueList = {
        "Orange"    : 10,
        "Warm white": 20,
        "Soft white": 23,
        "Yellow"    : 25,
        "Green"     : 39,
        "white"     : 52,
        "Daylight"  : 53,
        "Blue"      : 69,
        "DarkBlue"  : 70,
        "Purple"    : 75,
        "Pink"      : 83,
        "Red"       : 100,
        "Cyan"      : 180
}

def getHueLevel(colorMatch):
    return "{} ({})".format(colorMatch, colorHueList.get(colorMatch, None))

def getColorNameHue(hueValue):
    for k, v in colorHueList.items():
        if hueValue == v:
            return k
    return None

# Format percentages
def formatPercentage(val):
    if type(val) is int:
        return str(val) + "%"
    else:
        return val

# Format Timespan values in milliseconds
def formatTimespan(eventTime):
    minutes = (eventTime / (1000 * 60)) % 60
    hours = (eventTime / (1000 * 60 * 60)) % 24
    timespanString = ''
    if hours > 0: timespanString += str(hours) + " hour"
    if hours > 1: timespanString += "s"
    if hours == 0:
        if minutes == 0: timespanString += "less than a minute"
        if minutes == 1: timespanString += "a minute"
        if minutes > 1: timespanString += " " + str(minutes) + " minute"
    else:
        timespanString += " " + str(minutes) + " minute"
    if minutes > 1: timespanString += "s"
    return timespanString

# Return hex color code based on multiple step gradient (for thermo colors)
def numberToColorGrad(val, color):
    if color == 'red':
        if val == 5: return "#E50008"
        if val == 4: return "#EB1B20"
        if val == 3: return "#F23739"
        if val == 2: return "#F85352"
        if val == 1: return "#FF6F6B"
        if val == 0: return "#FF757A"
    if color == 'blue':
        if val == 5: return "#002FE5"
        if val == 4: return "#1745EA"
        if val == 3: return "#2E5BEF"
        if val == 2: return "#4671F4"
        if val == 1: return "#5D87F9"
        if val == 0: return "#759DFF"
    return "green"

# Define and Assign Display Options and check for None
def getOptions(dictvarname, nonedefault):
    tmp = options.get(dictvarname, nonedefault)
    return tmp if tmp is not None else nonedefault

# Builds the param statement for Xbar to launch the "open" command
# noinspection PyShadowingNames
def openParamBuilder(openCommand):
    rc = " terminal=false shell='{}' ".format(scriptFile)
    i = 0
    for word in openCommand.split():
        i += 1
        rc += "param{}='{}' ".format(i, word)
    return rc

def verifyInteger(intValue, errorIntValue):
    if isinstance(intValue, int):
        return intValue
    else:
        return errorIntValue

# Set URLs
f = dict(access_token=smartAppSecret,path=scriptFile,nodename=os.uname()[1])
statusURL = "{}{}{}".format(smartAppURL, "GetStatus/?", urllib.parse.urlencode(f))
contactURL = smartAppURL + "ToggleSwitch/?access_token=" + smartAppSecret + "&id="
valveURL = smartAppURL + "ToggleValve/?access_token=" + smartAppSecret + "&id="
levelURL = smartAppURL + "SetLevel/?access_token=" + smartAppSecret + "&id="
colorURL = smartAppURL + "SetColor/?access_token=" + smartAppSecret + "&id="
musicplayerURL = smartAppURL + "SetMusicPlayer/?access_token=" + smartAppSecret + "&id="
lockURL = smartAppURL + "ToggleLock/?access_token=" + smartAppSecret + "&id="
thermoURL = smartAppURL + "SetThermo/?access_token=" + smartAppSecret + "&id="
modeURL = smartAppURL + "SetMode/?access_token=" + smartAppSecret + "&id="
hsmURL = smartAppURL + "SetHSM/?access_token=" + smartAppSecret + "&id="

# Set the callback script for switch/level commands from parameters
callbackScript = "'{}'".format(scriptFile)

# Make the call the to the API and retrieve JSON data
# Create the urllib2 Request
header = {"Authorization": "Bearer " + smartAppSecret}
request = urllib.request.Request(statusURL, None, header)
# Getting the response
try:
    response = urllib.request.urlopen(request)
except (urllib.error.HTTPError, urllib.error.URLError) as err:
    print(":rage:")
    print("---")
    print(":thumbsdown: HTTPS Error Encountered: Communicating to Hub API caused the following error: {}".format(
        str(err)))
    print("==> Please check your Internet Connectivity and Refresh Xbar again when Online")
    exit(99)

# Check for Return Code Status
# noinspection PyUnboundLocalVariable
if response.code != 200:
    print(":rage:")
    print('---')
    print(":thumbsdown: Error Communicating with HE API, HTTPS rc={}".format(response.code))
    print("Content:", response.content)
    print("--Hubitat HTTP Server Response")
    for response_info_name in response.info():
        if response_info_name[0:6] == 'x-rate':
            print("----{:20} = {:>3}".format(response_info_name, response.info()[response_info_name]))
    exit(99)

# Parse the JSON data
try:
    j = json.loads(response.read())
except (ValueError,TypeError):
    pass

# API Return Error Handling
if "error" in j:
    print(":rage:")
    print('---')
    if j['error'] == 'invalid_token':
        print(":thumbsdown: Please verify that Oauth API String is correct.")
        print(" Please re-try again after verification of the Hubitat → Xbar API Oauth string.")
    print("Error Details: ", j['error'])
    if "error_description" in j:
        print(":thumbsdown: Error Description: ", j['error_description'])
    exit(99)

# Get the sensor arrays from the JSON data
# print (json.dumps(j, indent=2))
# exit(0)
try:
    contacts = j['Contact Sensors']
    currentmode = j['CurrentMode']
    hsmState = j['hsmState']
    hubName = j['hubName']
    locks = j['Locks']
    mainDisplay = j['MainDisplay']
    modes = j['Modes']
    motion = j['Motion Sensors']
    musicplayers = j['Music Players']
    options = j['Options']
    presences = j['Presence Sensors']
    relativeHumidityMeasurements = j['RelativeHumidityMeasurements']
    switches = j['Switches']
    temps = j['Temp Sensors']
    thermostats = j['Thermostats']
    valves = j['Valves']
    waters = j['Waters']
except KeyError as e:
    print(":rage:")
    print("---")
    print(":thumbsdown: Json File Import Error Details: ", e)
    exit(99)
    

def eventGroupByDate(tempList, prefix=None, valueSuffix=""):
    strLen = len(tempList)
    if strLen == 0: return
    # noinspection PyShadowingNames
    for x in range(0, strLen):
        curSplitRecord = tempList[x]['date'].split()
        if x == 0:
            print("--{}{} {} {}".format(
                prefix, curSplitRecord[0], curSplitRecord[1], curSplitRecord[2]
            ), buildFontOptions(3))
            sys.stdout.write("--")
        elif curSplitRecord[2] == tempList[x - 1]['date'].split()[2]:
            sys.stdout.write("--")
        else:
            print("--{}{} {} {}".format(
                prefix, curSplitRecord[0], curSplitRecord[1], curSplitRecord[2]
            ), buildFontOptions(3))
            sys.stdout.write("--")
        if tempList[x]['value'] is not None: tempList[x]['value'] = tempList[x]['value'].replace('\n', '')
        try:
            tempList[x]['value'] = "{} ({:4.1f})".format(tempList[x]['name'].title(), float(tempList[x]['value']))
        except (ValueError, TypeError, AttributeError):
            pass
        if eventsTimeFormat == "12 Hour Clock Format with AM/PM":
            print("--{}{} {} {} = {}{}".format(
                prefix, curSplitRecord[3], curSplitRecord[4], curSplitRecord[5], tempList[x]['value'], valueSuffix),
                buildFontOptions(4))
        else:
            print("--{}{} {} = {}{}".format(
                prefix, curSplitRecord[3], curSplitRecord[4], tempList[x]['value'], valueSuffix), buildFontOptions(4))
    return

# Set User Display Options sent from Xbar Output SmartApp
useImages = getOptions("useImages", True)
useAlbumArtworkImages = getOptions("useAlbumArtworkImages", False)
sortSensorsName = getOptions("sortSensorsName", True)
subMenuCompact = getOptions("subMenuCompact", False)
sortSensorsActive = getOptions("sortSensorsActive", True)
showSensorCount = getOptions("showSensorCount", True)
motionActiveEmoji = getOptions("motionActiveEmoji", '⇠⇢')
motionInactiveEmoji = getOptions("motionInactiveEmoji", '⇢⇠')
contactOpenEmoji = getOptions("contactOpenEmoji", '⇠⇢')
contactClosedEmoji = getOptions("contactClosedEmoji", '⇢⇠')
presenscePresentEmoji = getOptions("presenscePresentEmoji", ':house:')
presensceNotPresentEmoji = getOptions("presensceNotPresentEmoji", ':x:')
presenceDisplayMode = getOptions("presenceDisplayMode", 0)
mainFontName = "'{}'".format(getOptions("mainFontName", "Menlo"))
mainFontSize = getOptions("mainFontSize", "14").__str__()
fixedPitchFontSize = getOptions("fixedPitchFontSize", "14").__str__()
fixedPitchFontName = "'{}' ".format(getOptions("fixedPitchFontName", "Menlo"))
fixedPitchFontColor = getOptions("fixedPitchFontColor", "black")
subMenuFontName = "'{}'".format(getOptions("subMenuFontName", "Monaco"))
subMenuFontSize = getOptions("subMenuFontSize", "14").__str__()
subMenuFontColor = getOptions("subMenuFontColor", "black")
subMenuMoreColor = getOptions("subMenuMoreColor", "black")
hortSeparatorBarBool = getOptions("hortSeparatorBarBool", True)
hsmDisplayBool = getOptions("hsmDisplayBool", True)
eventsTimeFormat = getOptions("eventsTimeFormat", "12 Hour Clock Format with AM/PM")
sortTemperatureAscending = getOptions("sortTemperatureAscending", False)
favoriteDevices = getOptions("favoriteDevices", None)
colorChoices = getOptions("colorChoices", None)
colorBulbEmoji = getOptions("colorBulbEmoji", "🌈")
dimmerBulbEmoji = getOptions("dimmerBulbEmoji", "🔆")
dimmerValueOnMainMenu = getOptions("dimmerValueOnMainMenu", False)

hsmStates = ["armedAway", "armedHome", "armedNight", "disarmed"]
hsmCmds = ["armAway", "armHome", "armNight", "disarm", "armRules", "disarmRules", "disarmAll", "armAll", "cancelAlerts"]

# Read Temperature Formatting Settings
numberOfDecimals = verifyInteger(getOptions("numberOfDecimals", "0"), 0)

matchOutputNumberOfDecimals = getOptions("matchOutputNumberOfDecimals", False)
colorSwitch = True
smallFontPitchSize = "size={}".format(int(fixedPitchFontSize) - 1)

# Generates a Horizontal Separator Bar if desired by GUI
def hortSeparatorBar():
    if hortSeparatorBarBool: print("---")
    return

    # Check if MacOS is in Dark Mode
if XBARDarkMode:
    if "black" in subMenuFontColor.lower(): subMenuFontColor = "white"
    if "black" in subMenuMoreColor.lower(): subMenuMoreColor = "white"
    if "black" in fixedPitchFontColor.lower(): fixedPitchFontColor = "white"

# Define the Font Options string for Xbar
def buildFontOptions(level=1):
    # Level 0: MainMenu
    if level == 0:
        return " | font={} size={}".format(mainFontName, mainFontSize)
    # Level 1: SubMenu Titles (default)
    elif level == 1:
        return " | font={} size={} color='{}' ".format(subMenuFontName, subMenuFontSize, subMenuFontColor)
    # Level 2: SubMenu More Text
    elif level == 2:
        return " | font={} size={} color='{}' ".format(subMenuFontName, subMenuFontSize, subMenuMoreColor)
    # Level 3: Data Fixed Pitch Text
    elif level == 3:
        return " | font={} size={} color='{}' ".format(fixedPitchFontName, fixedPitchFontSize,
                                                     fixedPitchFontColor)
    # Level 4: Data Fixed Pitch Text, Trim=False
    elif level == 4:
        return " | font={} trim={} size={} color='{}' ".format(fixedPitchFontName, False, fixedPitchFontSize,
                                                             fixedPitchFontColor)
    # Level >4: No Formatting
    else:
        return " | "

# Setup the Main Menu and Sub Menu Display Relationship
mainMenuMaxItemsDict = {
        "Temps"                       : None,
        "MusicPlayers"                : None,
        "Contacts"                    : None,
        "Switches"                    : None,
        "Motion"                      : None,
        "Locks"                       : None,
        "Valves"                      : None,
        "Waters"                      : None,
        "RelativeHumidityMeasurements": None,
        "Presences"                   : None
}
mainMenuAutoSizeDict = {}
# mainMenuAutoSize = False

for sensorName in mainMenuMaxItemsDict:
    mainMenuMaxItemsDict[sensorName] = options.get("mainMenuMaxItems" + sensorName, None)
    if mainMenuMaxItemsDict[sensorName] is None:
        mainMenuMaxItemsDict[sensorName] = 999
        mainMenuAutoSizeDict[sensorName] = True
    #        mainMenuAutoSize = True
    else:
        mainMenuAutoSizeDict[sensorName] = False

# Sort Sensors & Values in Dictionary/Lists
if sortSensorsName is True:
    sortkey = 'name'
    if temps is not None:
        temps = sorted(temps, key=lambda k: k[sortkey])
    if contacts is not None:
        contacts = sorted(contacts, key=lambda k: k[sortkey])
    if switches is not None:
        switches = sorted(switches, key=lambda k: k[sortkey])
    if motion is not None:
        motion = sorted(motion, key=lambda k: k[sortkey])
    if mainDisplay is not None:
        mainDisplay = sorted(mainDisplay, key=lambda k: k[sortkey])
    if musicplayers is not None:
        musicplayers = sorted(musicplayers, key=lambda k: k[sortkey])
    if locks is not None:
        locks = sorted(locks, key=lambda k: k[sortkey])
    if relativeHumidityMeasurements is not None:
        relativeHumidityMeasurements = sorted(relativeHumidityMeasurements, key=lambda k: k[sortkey])
    if presences is not None:
        presences = sorted(presences, key=lambda k: k[sortkey])
    if modes is not None:
        modes = sorted(modes, key=lambda k: k[sortkey])

# Add a section to the submenu for special devices designated in the SmartApp
if DEBUG is False and favoriteDevices is not None:
    favoriteDevicesBool = True
    favoriteDevices = sorted(favoriteDevices)
else:
    favoriteDevicesBool = False

# if sortSensorsActive is True or mainMenuAutoSize is True:
if sortSensorsActive is True:
    sortkey = 'value'
    temps = sorted(temps, key=lambda k: k[sortkey], reverse=sortTemperatureAscending)
    contacts = sorted(contacts, key=lambda k: k[sortkey], reverse=True)
    switches = sorted(switches, key=lambda k: k[sortkey], reverse=True)
    motion = sorted(motion, key=lambda k: k[sortkey], reverse=False)
    locks = sorted(locks, key=lambda k: k[sortkey], reverse=True)
    relativeHumidityMeasurements = sorted(relativeHumidityMeasurements, key=lambda k: k[sortkey])
    presences = sorted(presences, key=lambda k: k[sortkey], reverse=True)
    musicplayers = sorted(musicplayers, key=lambda k: k['status'])

# Presence sort mode by status or in submenu, sort by value desc
if presenceDisplayMode == 1 or presenceDisplayMode == 2:
    presences = sorted(presences, key=lambda k: k['value'], reverse=True)

# Presence display mode only show present sensors
if presenceDisplayMode == 3:
    presences = [p for p in presences if p['value'] == 'present']

# Create a new NumberFormatter object
formatter = NumberFormatter()
# Set the number of decimals
formatter.setRoundingPrecision(numberOfDecimals)

# Format thermostat status color
thermoColor = ''
if (thermostats is not None) and (len(thermostats) > 0):
    if "thermostatOperatingState" in thermostats[0]:
        if thermostats[0]['thermostatOperatingState'] == "heating":
            thermoColor += "color=red"
        if thermostats[0]['thermostatOperatingState'] == "cooling":
            thermoColor += "color=blue"

# Print the main display
degree_symbol= u'\N{DEGREE SIGN}'
formattedMainDisplay = ''
mainMenuColor = ""

# Find the max length sensor so values are lined up correctly
maxLength = 0
maxDecimals = 0
for sensor in temps:
    if len(sensor['name']) > maxLength:
        maxLength = len(sensor['name'])
    if formatter.getNumberOfDecimals(sensor['value']) > maxDecimals:
        maxDecimals = formatter.getNumberOfDecimals(sensor['value'])

for sensor in contacts:
    if len(sensor['name']) > maxLength:
        maxLength = len(sensor['name'])
for sensor in switches:
    if len(sensor['name']) > maxLength:
        maxLength = len(sensor['name'])
for sensor in motion:
    if len(sensor['name']) > maxLength:
        maxLength = len(sensor['name'])
for sensor in locks:
    if len(sensor['name']) > maxLength:
        maxLength = len(sensor['name'])
for sensor in relativeHumidityMeasurements:
    if len(sensor['name']) > maxLength:
        maxLength = len(sensor['name'])

utilities = myUtilities()

# Increment maxLength by one since contact sensor icon needs to be pulled back a little
maxLength += 1
# MAIN MAC MENU BAR
# Iterate over the selected Main Menu Bar choices
if mainDisplay is not None:
    mainDisplaylen = len(mainDisplay)
    if mainDisplaylen > 0:
        for x in range(len(mainDisplay)):
            # Check if there is a integer value indicating a temperature value
            if isinstance(mainDisplay[x]['value'], int) or isinstance(mainDisplay[x]['value'], float):
                formattedMainDisplay += formatter.formatNumber(mainDisplay[x]['value']) + degree_symbol
                mainMenuColor = thermoColor
                print("{} | {} {} dropdown=false".format(formattedMainDisplay, 'size=14', mainMenuColor))
            elif mainDisplay[x]['emoji'] is not None:
                print("{} | dropdown=false".format(mainDisplay[x]['emoji']))
            else:
                formattedMainDisplay = "HE XBar"
                print("{} | {} {} dropdown=false".format(formattedMainDisplay, 'size=14', mainMenuColor))
    if mainDisplaylen > 0:
        maxLengthDisplayName = 0
        print("---")
        print("Main Menu Bar Icon Status ({}) {}".format(mainDisplaylen, buildFontOptions(2)))
        for x in range(len(mainDisplay)):
            if isinstance(mainDisplay[x]['value'], int) or isinstance(mainDisplay[x]['value'], float):
                mainDisplay[x]['value'] = str(mainDisplay[x]['value'])
                if mainDisplay[x]['capability'] == 'temperatureMeasurement':
                    mainDisplay[x]['value'] = mainDisplay[x]['value'] + degree_symbol
            elif mainDisplay[x]['capability'] == 'hsm':
                mainDisplay[x]['name'] = mainDisplay[x]['label']
            maxLengthDisplayName = len(mainDisplay[x]['name']) if len(mainDisplay[x]['name']) > maxLengthDisplayName else maxLengthDisplayName
        for x in range(len(mainDisplay)):
            print("--:small_blue_diamond: {} {} {} ".format(mainDisplay[x]['name'].ljust(maxLengthDisplayName, '.'), str(mainDisplay[x]['value']).upper(), buildFontOptions(3)))
else:
    formattedMainDisplay = "HE Xbar"
    print("{} | {} {} dropdown=false".format(formattedMainDisplay, 'size=14', mainMenuColor))

if favoriteDevicesBool:
    original_stdout = sys.stdout
    favoriteDevicesOutputDict = {}
    fo = tempfile.TemporaryFile()
    sys.stdout = fo

# Set the static amount of decimal places based on setting
if matchOutputNumberOfDecimals is True:
    formatter.setStaticDecimalPlaces(maxDecimals)
else:
    formatter.setStaticDecimalPlaces(-1)

# Begin outputting sensor data

# Output Thermostat data
if (thermostats is not None) and (len(thermostats) > 0):
    # noinspection SpellCheckingInspection
    thermoModeList = ["auto", "cool", "heat", "off"]
    for i, thermostat in enumerate(thermostats):
        if "thermostatMode" in thermostat and \
                "thermostatOperatingState" in thermostat:
            setpointText = ''
            setpointAction = ' @ '
            currentSetpoint = 0
            # Set the action text based on operation state
            # Example: cooling to 75, idle @ 72, heating to 68
            if thermostat['thermostatOperatingState'] == 'cooling' or thermostat['thermostatOperatingState'] \
                    == 'heating': setpointAction = ' to '
            # Pick the correction setpoint value
            if thermostat['thermostatMode'] == 'cool':
                currentSetpoint = thermostat['coolingSetpoint']
            elif thermostat['thermostatMode'] == 'heat':
                currentSetpoint = thermostat['heatingSetpoint']
            elif thermostat['thermostatMode'] == 'auto':
                if thermostat['thermostatOperatingState'] == 'cooling':
                    currentSetpoint = thermostat['coolingSetpoint']
                if thermostat['thermostatOperatingState'] == 'heating':
                    currentSetpoint = thermostat['heatingSetpoint']
            # Set the display string
            if thermostat['thermostatOperatingState'] not in ["idle", "off"]:
                setpointText = "(" + str(thermostat['thermostatOperatingState']) + setpointAction + str(
                    currentSetpoint) + degree_symbol + ")"
            else:
                setpointText = "({})".format(thermostat['thermostatOperatingState'])
            if "displayName" in thermostat:
                print(thermostat['displayName'], setpointText, buildFontOptions(3), 'image='+ utilities.getImageString("thermoImage"))
            else:
                print("Thermostat Control", setpointText, buildFontOptions(3), 'image='+ utilities.getImageString("thermoImage"))
            if not subMenuCompact: print("--Current Status", buildFontOptions())
            currentThermoURL = thermoURL + thermostat['id']
            thermoModeURL = currentThermoURL + "&type=mode&val="
            # Mode Menu
            if "thermostatMode" in thermostat:
                print("--Mode ({})".format(TitleCase(thermostat['thermostatMode'])), buildFontOptions(3))
                if not subMenuCompact: print("----Set Mode to:", buildFontOptions(1))
                for thermoMode in thermoModeList:
                    if thermoMode != thermostat['thermostatMode']:
                        thermo_param4 = 'param4=\"Setting {} to {}\"'.format(thermostat['displayName'], thermoMode)
                        print("----• {}".format(TitleCase(thermoMode)), buildFontOptions(3), \
                              "shell=" + callbackScript, " param1=request param2=" + thermoModeURL + thermoMode.lower(), \
                              " param3=Thermostat", thermo_param4, ' terminal=false refresh=false')
            # Cooling Setpoint Menu
            if "coolingSetpoint" in thermostat:
                if thermostat['coolingSetpoint'] is not None:
                    coolSetpointURL = currentThermoURL + "&type=coolingSetpoint&val="
                    currentCoolingSetPoint = int(thermostat['coolingSetpoint'])
                    print("--Cooling Set Point (" + str(currentCoolingSetPoint) + degree_symbol + ")", \
                          buildFontOptions(3), "color=blue")
                    print("----Change Setpoint | ", smallFontPitchSize)
                    for c in range(currentCoolingSetPoint - 5, currentCoolingSetPoint):
                        id = currentCoolingSetPoint - c
                        thermo_param4 = 'param4=\"Setting {} to {}\"'.format(thermostat['displayName'], str(c) + degree_symbol)
                        print("----• ", str(c) + degree_symbol, buildFontOptions(3), \
                              "color="+numberToColorGrad(id, "blue"), \
                              "shell="+ callbackScript, " param1=request param2="+str(
                                coolSetpointURL + str(c)), " param3=Thermostat", thermo_param4, " terminal=false refresh=false")
                    print("----", ':heavy_check_mark:', str(currentCoolingSetPoint) + degree_symbol, "| color=black size=14 font='Menlo Bold'")
                    for c in range(currentCoolingSetPoint + 1, currentCoolingSetPoint + 6):
                        thermo_param4 = 'param4=\"Setting {} to {}\"'.format(thermostat['displayName'], str(c) + degree_symbol)
                        print("----• ", str(c) + degree_symbol, buildFontOptions(3), "color=gray", \
                              "shell="+ callbackScript, " param1=request param2="+str(
                                coolSetpointURL + str(c)), " param3=Thermostat", thermo_param4, " terminal=false refresh=false")
            # Heating Setpoint Menu
            if "heatingSetpoint" in thermostat:
                if thermostat['heatingSetpoint'] is not None:
                    heatingSetpointURL = currentThermoURL + "&type=heatingSetpoint&val="
                    currentHeatingSetPoint = int(thermostat['heatingSetpoint'])
                    print("--Heating Set Point (" + str(currentHeatingSetPoint) + degree_symbol + ")", \
                          buildFontOptions(3), "color=red")
                    print("----Change Setpoint | ", smallFontPitchSize)
                    for c in range(currentHeatingSetPoint + 5, currentHeatingSetPoint, -1):
                        id = c - currentHeatingSetPoint
                        thermo_param4 = 'param4=\"Setting {} to {}\"'.format(thermostat['displayName'], str(c) + degree_symbol)
                        print("----• ", str(
                            c) + degree_symbol, buildFontOptions(3), "color="+numberToColorGrad(id, "red"), \
                              "shell=" + callbackScript, " param1=request param2=" + str(
                                heatingSetpointURL + str(c)), " param3=Thermostat", thermo_param4, " terminal=false refresh=false")
                    print("----", ':heavy_check_mark:', str(currentHeatingSetPoint) + degree_symbol, "| color=black size=14 font='Menlo Bold'")
                    for c in range(currentHeatingSetPoint - 1, currentHeatingSetPoint - 6, -1):
                        thermo_param4 = 'param4=\"Setting {} to {}\"'.format(thermostat['displayName'], str(c) + degree_symbol)
                        print("----• ", str(c) + degree_symbol, buildFontOptions(3), "color=gray", \
                              "shell=" + callbackScript, " param1=request param2=" + str(
                                heatingSetpointURL + str(c)), " param3=Thermostat", thermo_param4, " terminal=false refresh=false")

# Output Temp Sensors
if temps is not None:
    sensorName = "Temps"
    countSensors = len(temps)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Temp Sensors"
        mainTitle = menuTitle
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print("{} {}".format(mainTitle, buildFontOptions()))
        colorSwitch = False
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(temps):
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            for x in range(0, extraLength): whiteSpace += ' '
            colorText = ''
            currentValue = formatter.formatNumber(sensor['value'])
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                # noinspection PyTypeChecker
                print("{} More...{}".format(countSensors - mainMenuMaxItems, buildFontOptions(2)))
                if not subMenuCompact:
                    # noinspection PyTypeChecker
                    print("--{} ({})".format(menuTitle, str(countSensors - mainMenuMaxItems)), buildFontOptions())
                subMenuText = "--"
            print(subMenuText, sensor['name'], whiteSpace, currentValue + degree_symbol, \
                  buildFontOptions(3), colorText)
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                # noinspection PyUnboundLocalVariable
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + " " + \
                                                            currentValue + degree_symbol
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                try:
                    eventGroupByDate([d for d in sensor['eventlog'] if d['name'] in "temperature"], subMenuText, "°")
                except (ValueError, TypeError, AttributeError):
                    pass
            if sensor['battery'] != 'N/A':
                if sensor['battery'][1] != "": colorText = "color=red"
                print(subMenuText, sensor['name'], whiteSpace, formatPercentage(
                    sensor['battery'][0]) + sensor['battery'][1], buildFontOptions(3) + " alternate=true", colorText)
            colorSwitch = not colorSwitch

# Output relativeHumidityMeasurements Sensors
if relativeHumidityMeasurements is not None:
    sensorName = "RelativeHumidityMeasurements"
    countSensors = len(relativeHumidityMeasurements)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Relative Humidity Sensors"
        mainTitle = menuTitle
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print("{} {}".format(mainTitle, buildFontOptions()))
        colorSwitch = False
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(relativeHumidityMeasurements):
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            for x in range(0, extraLength): whiteSpace += ' '
            colorText = ''
            currentValue = formatter.formatNumber(sensor['value'])
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                # noinspection PyTypeChecker
                print("{} More...{}".format(countSensors - mainMenuMaxItems, buildFontOptions(2)))
                if not subMenuCompact:
                    # noinspection PyTypeChecker
                    print("--{} ({})".format(menuTitle, str(countSensors - mainMenuMaxItems)), buildFontOptions())
                subMenuText = "--"
            print(subMenuText, sensor['name'], whiteSpace, currentValue + "%", buildFontOptions(3), colorText)
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + " " + currentValue + "%"
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                eventGroupByDate([d for d in sensor['eventlog'] if d['name'] in "humidity"], subMenuText, "%")
            if sensor['battery'] != 'N/A':
                if sensor['battery'][1] != "": colorText = "color=red"
                print(subMenuText, sensor['name'], whiteSpace, formatPercentage(
                    sensor['battery'][0]) + sensor['battery'][1], buildFontOptions(3) + " alternate=true", colorText)
            colorSwitch = not colorSwitch

# Output Modes
if (modes is not None) and len(modes) > 0:
    hortSeparatorBar()
    if currentmode['name'] == "Home":
        emoji = " :house:"
    elif currentmode['name'] == "Night":
        emoji = ' :zzz:'
    else:
        emoji = ""
    if 20 <= int(time.strftime("%M")) <= 40:
        thirtyMin = '30'
    else:
        thirtyMin = ''
    emojiClock = " :clock{}{}:".format(time.strftime("%-I"), thirtyMin)
    print("{}'s Mode is {}{}{}{}".format(hubName,currentmode['name'], emoji, emojiClock, buildFontOptions()))
    print("--Modes (Select to Change)" + buildFontOptions())
    for i, mode in enumerate(modes):
        colorText = ''
        colorText = 'color=#333333' if colorSwitch else 'color=#666666'
        if mode['name'] not in currentmode['name']:
            currentModeURL = modeURL + urllib.parse.quote(mode['name'])
            mode_param4 = 'param4=\"Setting House Mode to {}\"'.format(mode['name'])
            print("--• " + mode[
                'name'], buildFontOptions(3), colorText, ' shell=' + callbackScript, ' param1=request param2=' + currentModeURL, \
                  ' param3=mode', mode_param4, ' terminal=false refresh=false')
        colorSwitch = not colorSwitch

# Output HSM Status
if hsmDisplayBool and hsmState is not None:
    if modes is None:
        hortSeparatorBar()
    colorText = ''
    print("Hubitat™ Safety Monitor is {}{}".format(hsmState.title(),buildFontOptions()))
    # Verify the HSM is configured:
    if hsmState != "unconfigured":
        print("--Select to Change" + buildFontOptions())
        for hsmCmd in hsmCmds:
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if hsmCmd in hsmState:
                currenthsmDisplay = " (Current)"
                currenthsmURL = ""
            else:
                currenthsmURL = hsmURL + hsmCmd
                currenthsmDisplay = ""
                hsm_param4 = 'param4=\"Setting HSM to {}\"'.format(hsmCmd.title())
                currenthsmURL = "shell=" + callbackScript + ' param1=request param2=' + currenthsmURL + ' param3=hsm ' + hsm_param4 + ' terminal=false refresh=false'
            print("--• {}{}".format(hsmCmd.title(), currenthsmDisplay), buildFontOptions(3), colorText, currenthsmURL)
            colorSwitch = not colorSwitch

# Output Contact Sensors
if contacts is not None:
    sensorName = "Contacts"
    countSensors = len(contacts)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Contact Sensors"
        subMenuTitle = "More..."
        mainTitle = menuTitle
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(contacts):
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            for x in range(0, extraLength): whiteSpace += ' '
            sym = ''
            if sensor['value'] == 'closed':
                sym = contactClosedEmoji
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Contact Sensors Closed..."
            else:
                sym = contactOpenEmoji
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions(2)))
                if not subMenuCompact: print("--{} ({})".format(menuTitle, str(countSensors - mainMenuMaxItems)), \
                                             buildFontOptions())
                subMenuText = "--"
            print(subMenuText, sensor['name'], whiteSpace, sym, buildFontOptions(3), colorText)
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + " " + sym
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                eventGroupByDate([d for d in sensor['eventlog']
                                  if d['name'] in ['status', 'contact', 'acceleration']], subMenuText, "")
            if sensor['battery'] != 'N/A':
                if sensor['battery'][1] != "": colorText = "color=red"
                print(subMenuText, sensor['name'], whiteSpace, formatPercentage(
                    sensor['battery'][0]) + sensor['battery'][1], buildFontOptions(3) + "alternate=true", colorText)
            colorSwitch = not colorSwitch

# Output Motion Sensors
if motion is not None:
    sensorName = "Motion"
    countSensors = len(motion)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Motion Sensors"
        subMenuTitle = "More..."
        mainTitle = menuTitle
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(motion):
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            for x in range(0, extraLength): whiteSpace += ' '
            sym = ''
            if sensor['value'] == 'inactive':
                sym = motionInactiveEmoji
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Sensors Inactive..."
            else:
                sym = motionActiveEmoji
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions(2)))
                if not subMenuCompact: print("-- " + menuTitle + " (" + str(countSensors - mainMenuMaxItems) + ")")
                subMenuText = "--"
            print(subMenuText, sensor['name'], whiteSpace, sym, buildFontOptions(3), colorText)
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + " " + sym
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                eventGroupByDate([d for d in sensor['eventlog'] if d['name'] == 'motion'], subMenuText, "")
            if sensor['battery'] != 'N/A':
                if sensor['battery'][1] != "": colorText = "color=red"
                print(subMenuText, sensor['name'], whiteSpace, formatPercentage(
                    sensor['battery'][0]) + sensor['battery'][1], buildFontOptions(3), " alternate=true", colorText)
            colorSwitch = not colorSwitch

# Output Presence Sensors
if presences is not None:
    sensorName = "Presences"
    countSensors = len(presences)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Presence Sensors"
        subMenuTitle = "More..."
        mainTitle = menuTitle
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        notPresentMenuText = ''
        notPresentSubmenu = False
        for i, sensor in enumerate(presences):
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            for x in range(0, extraLength): whiteSpace += ' '
            sym = ''
            if sensor['value'] == 'present':
                emoji = presenscePresentEmoji
            else:
                emoji = presensceNotPresentEmoji
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Sensors Not Present..."
            # Only show the More... menu if there is no presence submenu
            if i == mainMenuMaxItems and notPresentSubmenu is False:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions(2)))
                if not subMenuCompact: print("--{} ({}) {}".format(
                    menuTitle, str(countSensors - mainMenuMaxItems), buildFontOptions()
                ))
                subMenuText = "--"
            # If the presence mode is show not present in submenu
            if presenceDisplayMode == 2 and sensor['value'] != 'present':
                # If this is the first not present sensor
                if not notPresentSubmenu:
                    print(subMenuText, subMenuTitle, buildFontOptions())
                    notPresentSubmenu = True
                # Set the submenu text
                notPresentMenuText = "--"
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            print(subMenuText + notPresentMenuText, sensor['name'], whiteSpace, emoji, buildFontOptions(3), colorText)
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + " " + emoji
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                eventGroupByDate([d for d in sensor['eventlog'] if d['name'] in 'presence'], subMenuText, "")
            if sensor['battery'] != 'N/A':
                if sensor['battery'][1] != "": colorText = "color=red"
                print(subMenuText + notPresentMenuText, sensor['name'], whiteSpace, formatPercentage(
                    sensor['battery'][0]) + sensor['battery'][1], buildFontOptions(3) + " alternate=true", colorText)
            colorSwitch = not colorSwitch

# Output Locks
if locks is not None:
    sensorName = "Locks"
    countSensors = len(locks)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = sensorName
        subMenuTitle = "More..."
        mainTitle = menuTitle
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(locks):
            currentLockURL = lockURL + sensor['id']
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            img = ''
            sym = ''
            for x in range(0, extraLength): whiteSpace += ' '
            if sensor['value'] == 'locked':
                sym = '🔒'
                img = utilities.getImageString(sensor['value'])
                lock_param4 = 'param4=\"{} {}\"'.format('Unlocking', sensor['name'])
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Locked..."
            elif sensor['value'] == 'unlocked':
                sym = '🔓'
                img = utilities.getImageString(sensor['value'])
                lock_param4 = 'param4=\"{} {}\"'.format('Locking', sensor['name'])
            else:
                sym = '🔴'
                img = utilities.getImageString(sensor['value'])
                lock_param4 = ''
                sensor['name'] = "{} is {}".format(sensor['name'], sensor['value'])
            if i == mainMenuMaxItems:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions(2)))
                if not subMenuCompact: print("--{} ({}) {}".format(
                    menuTitle, str(countSensors - mainMenuMaxItems), buildFontOptions()
                ))
                subMenuText = "--"
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if useImages is True:
                print(subMenuText, sensor['name'] + ' is ' + sensor['value'].capitalize(), buildFontOptions(
                    3) + colorText + ' shell=' + callbackScript, ' param1=request param2=' + currentLockURL, \
                      ' param3={}'.format(utilities.devWaitSecs("locks")), lock_param4, ' terminal=false refresh=false image=' + img)
            else:
                print(subMenuText, sensor['name'] + ' is ' + sensor[
                    'value'].capitalize(), whiteSpace, sym, buildFontOptions(3) + colorText + ' shell=' + callbackScript, \
                      ' param1=request param2=' + currentLockURL, ' param3={}'.format(utilities.devWaitSecs("locks")), lock_param4, ' terminal=false refresh=false')
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + " " + sym
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                eventGroupByDate(
                    [d for d in sensor['eventlog'] if d['value'] in
                     ['locked', 'armed', 'unlocked', 'disarmed']], subMenuText, "")
            if sensor['battery'] != 'N/A':
                if sensor['battery'][1] != "": colorText = "color=red"
                if useImages is True:
                    print(subMenuText, sensor['name'], whiteSpace, formatPercentage(
                        sensor['battery'][0]) + sensor['battery'][1], \
                          buildFontOptions(3) + " alternate=true", colorText, "image=" + img)
                else:
                    print(subMenuText, sensor['name'], whiteSpace, sym, formatPercentage(
                        sensor['battery'][0]) + sensor['battery'][1], \
                          buildFontOptions(3) + " alternate=true", colorText)
            colorSwitch = not colorSwitch

# Output Switches & Lights
if switches is not None:
    sensorName = "Switches"
    countSensors = len(switches)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Lights & {}".format(sensorName)
        mainTitle = menuTitle
        subMenuTitle = "More..."
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(switches):
            thisSensor = sensor["name"]
            if sensor['isRGB'] is True:
                thisSensor = "{} {}".format(thisSensor, colorBulbEmoji)
            elif sensor['isDimmer'] is True:
                thisSensor = "{} {}".format(thisSensor, dimmerBulbEmoji)
            else:
                pass
            if (sensor['isRGB'] or sensor['isDimmer']) and dimmerValueOnMainMenu:
                thisSensor = "{} ({}%)".format(thisSensor, sensor["dimmerLevel"])
            indent = ""
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            img = ''
            for x in range(0, extraLength): whiteSpace += ' '
            if sensor['value'] == 'on':
                sym = " ✅"
                img = utilities.getImageString('greenImage')
                switch_param4 = 'param4=\"{} {}\"'.format('Turning Off', sensor['name'])
            else:
                sym = " 🔴"
                img = utilities.getImageString('redImage')
                switch_param4 = 'param4=\"{} {}\"'.format('Turning On', sensor['name'])
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Switches Off..."
            currentSwitchURL = contactURL + sensor['id']
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions()))
                if not subMenuCompact: print("--{} ({}) {}".format(
                    menuTitle, str(countSensors - mainMenuMaxItems), buildFontOptions(2)
                ))
                subMenuText = "--"
            if useImages is True:
                print(subMenuText, thisSensor, buildFontOptions(3) + colorText + ' shell=' + callbackScript, \
                      ' param1=request param2=' + currentSwitchURL, ' param3=' + smartAppSecret, switch_param4, ' terminal=false refresh=false image=' + img)
            else:
                print(subMenuText, thisSensor, whiteSpace, sym, buildFontOptions(
                    3) + colorText + ' shell=' + callbackScript, \
                      ' param1=request param2=' + currentSwitchURL, ' param3=' + smartAppSecret, switch_param4, ' terminal=false refresh=false')
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + sym
            indent = ""
            if sensor['isDimmer'] is True:
                subMenuText = subMenuText + '--'
                print(subMenuText + dimmerBulbEmoji + ' Current Dimmer Level ({}%)'.format(sensor["dimmerLevel"]), \
                      buildFontOptions(3), smallFontPitchSize)
                if sensor['isRGB']: subMenuText = subMenuText + '--'
                print(subMenuText + dimmerBulbEmoji + ' Set Dimmer Level to:', buildFontOptions(3), smallFontPitchSize)
                count = 0
                for currentLevel in range(10, 110, 10):
                    currentLevelURL = levelURL + sensor['id'] + '&level=' + str(currentLevel)
                    count += 1
                    print(subMenuText + "   • {:>4}".format(str(currentLevel) + "%"), buildFontOptions(4), \
                          'shell=' + callbackScript, ' param1=request param2=' + currentLevelURL, \
                          ' param3=' + smartAppSecret, switch_param4, ' terminal=false refresh=false')
                if sensor['isRGB']:
                    subMenuText = subMenuText[:-4]
                else:
                    subMenuText = subMenuText[:-2]
                indent = '--'
            if sensor['isRGB'] is True and colorChoices > 0:
                subMenuText = subMenuText + '--'
                colorName = getColorNameHue(sensor["hue"])
                if colorName is None: colorName = sensor["colorRGBName"]
                print(subMenuText + colorBulbEmoji + " Current Hue Value ({} Hue: {})".format(colorName, sensor["hue"]), \
                      buildFontOptions(3), smallFontPitchSize)
                subMenuText = subMenuText + '--'
                print(subMenuText + colorBulbEmoji + ' Set Hue to:', buildFontOptions(3), smallFontPitchSize)
                count = 0
                for colorChoice in colorChoices:
                    if colorName == colorChoice: continue
                    count += 1
                    if colorChoice == 'white':
                        colorChoiceSafe = 'black'
                    else:
                        colorChoiceSafe = colorChoice.split(' ', 1)[0]
                    currentColorURL = colorURL + sensor['id'] + '&colorName=' + urllib.parse.quote(colorChoice)
                    print(subMenuText + "{:>3}. {} ".format(count, getHueLevel(colorChoice)), buildFontOptions(4), \
                          'shell=' + callbackScript, ' param1=request param2=' + currentColorURL, ' param3=' + smartAppSecret, \
                          switch_param4, ' terminal=false refresh=false', 'color=' + colorChoiceSafe)
                subMenuText = subMenuText[:-2]
                print(subMenuText + colorBulbEmoji + ' Current Sat Value ({}) '.format(sensor["saturation"]), \
                      buildFontOptions(3), smallFontPitchSize)
                subMenuText = subMenuText + '--'
                print(subMenuText + colorBulbEmoji + ' Set Saturation to:', buildFontOptions(3), smallFontPitchSize)
                count = 0
                for currentLevel in range(0, 110, 10):
                    currentColorURL = colorURL + sensor['id'] + '&saturation=' + str(currentLevel)
                    count += 1
                    print(subMenuText + "{:>3}. {:>4}".format(count, str(currentLevel)), buildFontOptions(4), \
                          'shell=' + callbackScript, ' param1=request param2=' + currentColorURL, ' param3=' + smartAppSecret, \
                          switch_param4, ' terminal=false refresh=false')
                subMenuText = subMenuText[:-4]
                indent = '--'
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                print(subMenuText + "-- 🎯 Event History", buildFontOptions(3))
                eventGroupByDate(sensor['eventlog'], subMenuText + indent, "")
            colorSwitch = not colorSwitch

# Output Media Players
if musicplayers is not None:
    sensorName = "MusicPlayers"
    countSensors = len(musicplayers)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Media Players"
        mainTitle = menuTitle
        subMenuTitle = "More Media Players..."
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        # noinspection PyShadowingNames
        musicplayers = sorted(musicplayers, key=lambda x: x['name'], reverse=False)
        musicplayers = sorted(musicplayers, key=lambda x: x['manufacturer'], reverse=True)
        # noinspection PyShadowingNames
        for i, sensor in enumerate(sorted(musicplayers, key=lambda x: x['groupRolePrimary'], reverse=True)):
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            img = ''
            for x in range(0, extraLength): whiteSpace += ' '
            if sensor['status'] == 'playing':
                sym = '🔛'
                img = utilities.getImageString('greenImage')
            else:
                sym = '🔴'
                img = utilities.getImageString('redImage')
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Media Players Inactive..."
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions()))
                if not subMenuCompact: print("--{} ({}) {}".format(
                    menuTitle, str(countSensors - mainMenuMaxItems), buildFontOptions(2)
                ))
                subMenuText = "--"
            if sensor['groupRole'] is not None: sensor['name'] = "{} - ({})".format(sensor['name'], sensor['groupRole'].capitalize())
            if useImages is True:
                print(subMenuText, sensor['name'], buildFontOptions(3) + colorText, 'image=' + img)
            else:
                print(subMenuText, sensor['name'], whiteSpace, sym, buildFontOptions(3) + colorText)

            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + whiteSpace + " " + sym
            if sensor['level'] is not None:
                if sensor['manufacturer'] is not None:
                    print("{}--{}".format(subMenuText, sensor['manufacturer']), buildFontOptions(2))
                print("{}--• Volume: {} % of Maximum".format(subMenuText, sensor['level']), buildFontOptions(3))
                print("{}----Change Music Volume".format(subMenuText), buildFontOptions(3), smallFontPitchSize)
                currentLevel = 0
                while currentLevel <= 100:
                    currentMusicPlayerURL = "{}{}&command=level&level={}".format(musicplayerURL, sensor['id'], currentLevel)
                    musicplayers_param4 = ' param4=\"{} {}\"'.format('Changing volume to', currentLevel)
                    print("{}----• {}".format(subMenuText, currentLevel), buildFontOptions(3), \
                          'shell=' + callbackScript, 'param1=request param2=' + currentMusicPlayerURL, \
                          ' param3=' + smartAppSecret, musicplayers_param4, ' terminal=false refresh=false')
                    currentLevel += 5
            if sensor['mute'] is not None:
                for command in ["mute", "unmute"]:
                    musicplayers_param4 = 'param4=\"{} {}\"'.format('MediaPlayer:', TitleCase(command))
                    if sensor['mute'].startswith(command):
                        muteState = " :white_check_mark: "
                    else:
                        muteState = '• '
                    print("{}--{}{}".format(subMenuText, muteState, TitleCase(command)), buildFontOptions(3), 'shell=' + callbackScript, \
                          'param1=request param2=' + musicplayerURL + sensor['id'] + '&command=' + command, ' param3=' + smartAppSecret, musicplayers_param4, 'terminal=false refresh=false')
            if sensor['supportedCommands'] is not None:
                for supportedCommand in sorted(sensor['supportedCommands']):
                    musicplayers_param4 = 'param4=\"{} {}\"'.format('MusicPlayer:', TitleCase(supportedCommand))
                    print("{}--• {}".format(subMenuText, TitleCase(supportedCommand)), buildFontOptions(3), 'shell=' + callbackScript, \
                          'param1=request param2=' + musicplayerURL + sensor['id'] + '&command=' + supportedCommand, \
                          ' param3=' + smartAppSecret, musicplayers_param4, 'terminal=false refresh=false')
            if sensor["audioTrackData"] not in [None, '{}', '']:
                albumArtworkImageLink = ''
                albumArtwortkBullet = ''
                errorURL = False
                padwidth = 10
                try:
                    sensor["audioTrackData"] = json.loads(sensor["audioTrackData"])
                except ValueError:
                    errorURL = True
                    useAlbumArtworkImages = False
                print("{}--• Track Now Playing Info".format(subMenuText), buildFontOptions(3))
                albumArtwortkBullet = ''
                if "albumArtUrl" in sensor["audioTrackData"] and sensor["audioTrackData"]['albumArtUrl'].startswith("http"):
                    albumArtwortkBullet = '•'
                    url = sensor["audioTrackData"]['albumArtUrl']
                    if useAlbumArtworkImages:
                        try:
                            req = urllib.request.Request(url, headers={'User-Agent': "Magic Browser"})
                            rawImage = urllib.request.urlopen(req)
                            albumArtworkImageLink = " image=" + base64.b64encode(io.StringIO(rawImage.read()).getvalue())
                        except Exception as e:
                            errorMessage = e
                            albumArtworkImageLink = " href={}".format(url)
                            useAlbumArtworkImages = False
                            errorURL = True
                    else:
                        albumArtworkImageLink = " href={}".format(url)
                else:
                    padwidth = 8
                for key, value in sorted(sensor["audioTrackData"].items()):
                    if key == "album":
                        if errorURL:
                            print("{}----•{:{width}}: {}".format(subMenuText, TitleCase(key), value, width=padwidth), buildFontOptions(3))
                            print("{}------ErrorURL: {}".format(subMenuText, url), buildFontOptions(3))
                            print("{}------ErrorMessage: {}".format(subMenuText, errorMessage), buildFontOptions(3))
                        else:
                            if useAlbumArtworkImages:
                                print("{}----{} {:{width}}: {}".format(subMenuText, albumArtwortkBullet, TitleCase(key), value, width=padwidth), buildFontOptions(3))
                                print("{}------ ".format(subMenuText), buildFontOptions(3), albumArtworkImageLink)
                            else:
                                print("{}----{} {:{width}}: {}".format(subMenuText, albumArtwortkBullet, TitleCase(key), value, width=padwidth), buildFontOptions(3), albumArtworkImageLink)
                    elif key != "albumArtUrl":
                        print("{}----{:{width}}: {}".format(subMenuText, TitleCase(key), value, width=padwidth + 2), buildFontOptions(3))
            if sensor['presets'] is not None:
                print("{}--• {} Favorite Playlists".format(subMenuText, sensor['manufacturer']), buildFontOptions(3))
                print("{}----Select Favorite Playlist Preset".format(subMenuText), buildFontOptions(3), smallFontPitchSize)
                for num, preset in enumerate(json.loads(sensor['presets']), start=1):
                    currentMusicPlayerURL = "{}{}&command=preset&presetid={}".format(musicplayerURL, sensor['id'], preset['id'])
                    musicplayers_param4 = ' param4=\"Playing {}\"'.format(preset['name'].replace('"', '\\"').replace("'", ''))
                    print("{}----• {:2d}. {}".format(subMenuText, num, preset['name']), buildFontOptions(3), \
                          'shell=' + callbackScript, 'param1=request param2=' + currentMusicPlayerURL, \
                          ' param3=' + smartAppSecret, musicplayers_param4, ' terminal=false refresh=false length=40')
            if sensor['alexaPlaylists']:
                print("{}--• {} Favorite Playlists".format(subMenuText, sensor['manufacturer']), buildFontOptions(3))
                print("{}----Favorite Playlists (Voice Cmd Only)".format(subMenuText), buildFontOptions(3), smallFontPitchSize)
                for num, alexaPlaylist in enumerate(sensor['alexaPlaylists'][1:-3].split('}], '), start=1):
                    alexaPlaylistObj = re.search("^(.*?)=.*?playlistId=(.*?),.*", alexaPlaylist)
                    if alexaPlaylistObj:
                        print("{}----{:2d}. {}".format(subMenuText, num, alexaPlaylistObj.group(1)), buildFontOptions(3))
                        # Echo Speaks DTH does not support invoking playlists like Sonos at this time.
                        # currentMusicPlayerURL = "{}{}&command=preset&presetid={}".format(musicplayerURL, sensor['id'], alexaPlaylistObj.group(2))
                        # musicplayers_param4 = ' param4=\"Playing {}\"'.format(alexaPlaylistObj.group(1).replace('"', '\\"').replace("'", ''))
                        # print "{}----• {}".format(subMenuText, alexaPlaylistObj.group(1)), buildFontOptions(3), \
                        #     'shell=' + callbackScript, 'param1=request param2=' + currentMusicPlayerURL, \
                        #     ' param3=' + smartAppSecret, musicplayers_param4, ' terminal=false refresh=false length=40'
            colorSwitch = not colorSwitch

# Output Valves
if valves is not None:
    sensorName = "Valves"
    countSensors = len(valves)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = sensorName
        mainTitle = menuTitle
        subMenuTitle = "More..."
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(valves):
            thisSensor = sensor["name"]
            indent = ""
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            img = ''
            for x in range(0, extraLength): whiteSpace += ' '
            if sensor['value'] == 'open':
                sym = " ✅"
                img = utilities.getImageString('greenImage')
                valve_param4 = 'param4=\"{} {}\"'.format('Closing valve', sensor['name'])
            else:
                sym = " 🔴"
                img = utilities.getImageString('redImage')
                valve_param4 = 'param4=\"{} {}\"'.format('Opening valve', sensor['name'])
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Valves Close..."
            currentValveURL = valveURL + sensor['id']
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions()))
                if not subMenuCompact: print("--{} ({}) {}".format(
                    menuTitle, str(countSensors - mainMenuMaxItems), buildFontOptions(2)
                ))
                subMenuText = "--"
            if useImages is True:
                print(subMenuText, thisSensor, buildFontOptions(3) + colorText + ' shell=' + callbackScript, \
                      ' param1=request param2=', currentValveURL, ' param3=', smartAppSecret, valve_param4, ' terminal=false refresh=false image=', img)
            else:
                print(subMenuText, thisSensor, whiteSpace, sym, buildFontOptions(
                    3) + colorText + ' shell=' + callbackScript, ' param1=request param2=', currentValveURL, \
                      ' param3=', smartAppSecret, valve_param4, ' terminal=false refresh=false')
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + sym
            indent = ""
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                print(subMenuText + "-- 🎯 Event History", buildFontOptions(3))
                eventGroupByDate(sensor['eventlog'], subMenuText + indent, "")
            colorSwitch = not colorSwitch

# Output Water Sensors
if waters is not None:
    sensorName = "Waters"
    countSensors = len(waters)
    if countSensors > 0:
        hortSeparatorBar()
        menuTitle = "Water Sensors"
        subMenuTitle = "More..."
        mainTitle = menuTitle
        if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
        print(mainTitle, buildFontOptions())
        mainMenuMaxItems = mainMenuMaxItemsDict[sensorName]
        subMenuText = ''
        for i, sensor in enumerate(waters):
            currentLength = len(sensor['name'])
            extraLength = maxLength - currentLength
            whiteSpace = ''
            for x in range(0, extraLength): whiteSpace += ' '
            sym = ''
            if sensor['value'] == 'wet':
                sym = ":potable_water:"
                if mainMenuAutoSizeDict[sensorName] is True:
                    if mainMenuMaxItems > i: mainMenuMaxItems = i
                    subMenuTitle = "More Sensors Inactive..."
            else:
                sym = dimmerBulbEmoji
            colorText = 'color=#333333' if colorSwitch else 'color=#666666'
            if i == mainMenuMaxItems:
                print("{} {} {}".format(countSensors - mainMenuMaxItems, subMenuTitle, buildFontOptions(2)))
                if not subMenuCompact: print("-- " + menuTitle + " (" + str(countSensors - mainMenuMaxItems) + ")")
                subMenuText = "--"
            print(subMenuText, sensor['name'], whiteSpace, sym, buildFontOptions(3), colorText)
            if favoriteDevicesBool and sensor['name'] in favoriteDevices:
                favoriteDevicesOutputDict[sensor['name']] = sensor['name'] + whiteSpace + " " + sym
            if (sensor['eventlog'] is not None) and (len(sensor['eventlog']) > 0):
                eventGroupByDate([d for d in sensor['eventlog'] if d['name'] in 'water'], subMenuText, "")
            if sensor['battery'] != 'N/A':
                if sensor['battery'][1] != "": colorText = "color=red"
                print(subMenuText, sensor['name'], whiteSpace, formatPercentage(
                    sensor['battery'][0]) + sensor['battery'][1], buildFontOptions(3), " alternate=true", colorText)
            colorSwitch = not colorSwitch

# Configuration Options
hortSeparatorBar()
stop = timeit.default_timer()
print (":crystal_ball: Hubitat → Xbar Actions and Shortcuts" + buildFontOptions(2))
print ("--• Xbar Plugin GUI Options" + buildFontOptions())
print ("----" + sys.argv[0] + buildFontOptions())

printFormatString = "----{:" + len(max(options, key=len)).__str__() + "} = {} {}"
for option in sorted(options):
    if options[option] is not None and option == 'favoriteDevices' and len(favoriteDevices) > 1:
        for i, v in enumerate(options[option]):
            print (printFormatString.format(option + "(" + str(i + 1) + ")", v, buildFontOptions(3)))
    else:
        print (printFormatString.format(
            option, options[option] if options[option] is not None else "{Default Set in GUI}", buildFontOptions(3)
        ))
print ("--:loop: Program Execution RunTine: {:.1f} secs".format(stop - start), buildFontOptions(4))

if favoriteDevicesBool:
    # noinspection PyUnboundLocalVariable
    sys.stdout = original_stdout
    # noinspection PyUnboundLocalVariable
    fo.seek(0, 0)
    countSensors = len(favoriteDevices)
    mainTitle = "My Favorite Devices"
    if showSensorCount: mainTitle += " (" + str(countSensors) + ")"
    for key in favoriteDevices:
        # noinspection PyBroadException
        try:
            print (":small_blue_diamond: " + favoriteDevicesOutputDict[key] + ' | color=black font=Monaco  size=11')
        except:
            continue
    print ('---')
    print (fo.read())
    fo.close()
